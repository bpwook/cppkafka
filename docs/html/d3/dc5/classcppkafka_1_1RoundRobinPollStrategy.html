<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppkafka: cppkafka::RoundRobinPollStrategy Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppkafka
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cppkafka</b></li><li class="navelem"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html">RoundRobinPollStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../dc/d10/classcppkafka_1_1RoundRobinPollStrategy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppkafka::RoundRobinPollStrategy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This adapter changes the default polling strategy of the <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> into a fair round-robin polling mechanism.  
 <a href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d94/roundrobin__poll__strategy_8h_source.html">roundrobin_poll_strategy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cppkafka::RoundRobinPollStrategy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.png" usemap="#cppkafka::RoundRobinPollStrategy_map" alt=""/>
  <map id="cppkafka::RoundRobinPollStrategy_map" name="cppkafka::RoundRobinPollStrategy_map">
<area href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html" title="Base implementation of the PollInterface." alt="cppkafka::PollStrategyBase" shape="rect" coords="0,56,205,80"/>
<area href="../../d5/d33/structcppkafka_1_1PollInterface.html" title="Interface defining polling methods for the Consumer class." alt="cppkafka::PollInterface" shape="rect" coords="0,0,205,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a03e93ff0b2be16bf677590ab7ebcdd54"><td class="memItemLeft" align="right" valign="top"><a id="a03e93ff0b2be16bf677590ab7ebcdd54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RoundRobinPollStrategy</b> (<a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html">Consumer</a> &amp;consumer)</td></tr>
<tr class="separator:a03e93ff0b2be16bf677590ab7ebcdd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407eaed77dd3da0b6d483bbba12f7156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a407eaed77dd3da0b6d483bbba12f7156">poll</a> () override</td></tr>
<tr class="separator:a407eaed77dd3da0b6d483bbba12f7156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574b61ec5d1991293dc0b8a2e4d510d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a574b61ec5d1991293dc0b8a2e4d510d8">poll</a> (std::chrono::milliseconds timeout) override</td></tr>
<tr class="separator:a574b61ec5d1991293dc0b8a2e4d510d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a4024a8bd20b80318e287b4ad8391b"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a49a4024a8bd20b80318e287b4ad8391b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch</a> (size_t max_batch_size, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a49a4024a8bd20b80318e287b4ad8391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c0fb2c3f920111d7636501bb2dca55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#ab0c0fb2c3f920111d7636501bb2dca55">poll_batch</a> (size_t max_batch_size) override</td></tr>
<tr class="memdesc:ab0c0fb2c3f920111d7636501bb2dca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls all assigned partitions for a batch of new messages in round-robin fashion.  <a href="#ab0c0fb2c3f920111d7636501bb2dca55">More...</a><br /></td></tr>
<tr class="separator:ab0c0fb2c3f920111d7636501bb2dca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc2ccc525a9dcf311bb239ee664866d"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:acbc2ccc525a9dcf311bb239ee664866d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#acbc2ccc525a9dcf311bb239ee664866d">poll_batch</a> (size_t max_batch_size, std::chrono::milliseconds timeout, const Allocator &amp;alloc)</td></tr>
<tr class="separator:acbc2ccc525a9dcf311bb239ee664866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d4621a17f47db3f04b774ab29de9e5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a18d4621a17f47db3f04b774ab29de9e5">poll_batch</a> (size_t max_batch_size, std::chrono::milliseconds timeout) override</td></tr>
<tr class="memdesc:a18d4621a17f47db3f04b774ab29de9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls all assigned partitions for a batch of new messages in round-robin fashion.  <a href="#a18d4621a17f47db3f04b774ab29de9e5">More...</a><br /></td></tr>
<tr class="separator:a18d4621a17f47db3f04b774ab29de9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcppkafka_1_1PollStrategyBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcppkafka_1_1PollStrategyBase')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html">cppkafka::PollStrategyBase</a></td></tr>
<tr class="memitem:a3bf4b62ec49f60dcfec9302d2e55d3ab inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a3bf4b62ec49f60dcfec9302d2e55d3ab">PollStrategyBase</a> (<a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html">Consumer</a> &amp;consumer)</td></tr>
<tr class="memdesc:a3bf4b62ec49f60dcfec9302d2e55d3ab inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a3bf4b62ec49f60dcfec9302d2e55d3ab">More...</a><br /></td></tr>
<tr class="separator:a3bf4b62ec49f60dcfec9302d2e55d3ab inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f0278eb5de51df330164a2001b21ca inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top"><a id="a75f0278eb5de51df330164a2001b21ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a75f0278eb5de51df330164a2001b21ca">~PollStrategyBase</a> ()</td></tr>
<tr class="memdesc:a75f0278eb5de51df330164a2001b21ca inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a75f0278eb5de51df330164a2001b21ca inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78071e0bc763d891a637877753a25b54 inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a78071e0bc763d891a637877753a25b54">set_timeout</a> (std::chrono::milliseconds timeout) override</td></tr>
<tr class="separator:a78071e0bc763d891a637877753a25b54 inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e671507a1d15c97a7d038262eb32f3f inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a8e671507a1d15c97a7d038262eb32f3f">get_timeout</a> () override</td></tr>
<tr class="separator:a8e671507a1d15c97a7d038262eb32f3f inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b36c0eddb3be4f6e5baee1a76e8017 inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html">Consumer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a67b36c0eddb3be4f6e5baee1a76e8017">get_consumer</a> () final</td></tr>
<tr class="separator:a67b36c0eddb3be4f6e5baee1a76e8017 inherit pub_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7e70e386018b776a2625a244b79e23c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a7e70e386018b776a2625a244b79e23c0">reset_state</a> () final</td></tr>
<tr class="separator:a7e70e386018b776a2625a244b79e23c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9302acd97116723a7d5707d5f34820b"><td class="memItemLeft" align="right" valign="top"><a id="ac9302acd97116723a7d5707d5f34820b"></a>
<a class="el" href="../../d1/d6e/structcppkafka_1_1QueueData.html">QueueData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_next_queue</b> ()</td></tr>
<tr class="separator:ac9302acd97116723a7d5707d5f34820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcppkafka_1_1PollStrategyBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcppkafka_1_1PollStrategyBase')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html">cppkafka::PollStrategyBase</a></td></tr>
<tr class="memitem:a92fd16152961d6cdc81d458a373dd0a9 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">QueueMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a92fd16152961d6cdc81d458a373dd0a9">get_partition_queues</a> ()</td></tr>
<tr class="memdesc:a92fd16152961d6cdc81d458a373dd0a9 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queues from all assigned partitions.  <a href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a92fd16152961d6cdc81d458a373dd0a9">More...</a><br /></td></tr>
<tr class="separator:a92fd16152961d6cdc81d458a373dd0a9 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba752772ae5e0df941c4aff67bc979 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d6e/structcppkafka_1_1QueueData.html">QueueData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a25ba752772ae5e0df941c4aff67bc979">get_consumer_queue</a> ()</td></tr>
<tr class="memdesc:a25ba752772ae5e0df941c4aff67bc979 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the main consumer queue which services the underlying <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> object.  <a href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a25ba752772ae5e0df941c4aff67bc979">More...</a><br /></td></tr>
<tr class="separator:a25ba752772ae5e0df941c4aff67bc979 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aa2ce83c7097708053a313fef09143 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a40aa2ce83c7097708053a313fef09143">on_assignment</a> (TopicPartitionList &amp;partitions)</td></tr>
<tr class="memdesc:a40aa2ce83c7097708053a313fef09143 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called when a new partition assignment takes place.  <a href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a40aa2ce83c7097708053a313fef09143">More...</a><br /></td></tr>
<tr class="separator:a40aa2ce83c7097708053a313fef09143 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc43793f33351d50689f194889ff20a inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#abdc43793f33351d50689f194889ff20a">on_revocation</a> (const TopicPartitionList &amp;partitions)</td></tr>
<tr class="memdesc:abdc43793f33351d50689f194889ff20a inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called when an old partition assignment gets revoked.  <a href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#abdc43793f33351d50689f194889ff20a">More...</a><br /></td></tr>
<tr class="separator:abdc43793f33351d50689f194889ff20a inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22e5942b0f1fc236a067451dd46e831 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#ad22e5942b0f1fc236a067451dd46e831">on_rebalance_error</a> (<a class="el" href="../../d6/d72/classcppkafka_1_1Error.html">Error</a> error)</td></tr>
<tr class="memdesc:ad22e5942b0f1fc236a067451dd46e831 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called when a topic rebalance error happens.  <a href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#ad22e5942b0f1fc236a067451dd46e831">More...</a><br /></td></tr>
<tr class="separator:ad22e5942b0f1fc236a067451dd46e831 inherit pro_methods_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcppkafka_1_1PollStrategyBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcppkafka_1_1PollStrategyBase')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html">cppkafka::PollStrategyBase</a></td></tr>
<tr class="memitem:a89f89a78d4751ff7a5abb6c4c11a874e inherit pub_types_classcppkafka_1_1PollStrategyBase"><td class="memItemLeft" align="right" valign="top"><a id="a89f89a78d4751ff7a5abb6c4c11a874e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QueueMap</b> = std::map&lt; <a class="el" href="../../db/dfc/classcppkafka_1_1TopicPartition.html">TopicPartition</a>, <a class="el" href="../../d1/d6e/structcppkafka_1_1QueueData.html">QueueData</a> &gt;</td></tr>
<tr class="separator:a89f89a78d4751ff7a5abb6c4c11a874e inherit pub_types_classcppkafka_1_1PollStrategyBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This adapter changes the default polling strategy of the <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> into a fair round-robin polling mechanism. </p>
<p>The default librdkafka (and cppkafka) <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a407eaed77dd3da0b6d483bbba12f7156">poll()</a> and <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch()</a> behavior is to consume batches of messages from each partition in turn. For performance reasons, librdkafka pre-fetches batches of messages from the kafka broker (one batch from each partition), and stores them locally in partition queues. Since all the internal partition queues are forwarded by default unto the group consumer queue (one per consumer), these batches end up being polled and consumed in the same sequence order. This adapter allows fair round-robin polling of all assigned partitions, one message at a time (or one batch at a time if <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch()</a> is used). Note that <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch()</a> has nothing to do with the internal batching mechanism of librdkafka.</p>
<p>Example code on how to use this:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a consumer</span></div><div class="line">Consumer consumer(...);</div><div class="line">consumer.subscribe({ <span class="stringliteral">&quot;my_topic&quot;</span> });</div><div class="line"></div><div class="line"><span class="comment">// Optionally set the callbacks. This must be done *BEFORE* creating the strategy adapter</span></div><div class="line">consumer.set_assignment_callback(...);</div><div class="line">consumer.set_revocation_callback(...);</div><div class="line">consumer.set_rebalance_error_callback(...);</div><div class="line"></div><div class="line"><span class="comment">// Create the adapter and use it for polling</span></div><div class="line">RoundRobinPollStrategy poll_strategy(consumer);</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line">    <span class="comment">// Poll each partition in turn</span></div><div class="line">    Message msg = poll_strategy.poll();</div><div class="line">    <span class="keywordflow">if</span> (msg) {</div><div class="line">        <span class="comment">// process valid message</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Calling directly <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a407eaed77dd3da0b6d483bbba12f7156">poll()</a> or <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch()</a> on the <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> object while using this adapter will lead to undesired results since the <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html" title="This adapter changes the default polling strategy of the Consumer into a fair round-robin polling mec...">RoundRobinPollStrategy</a> modifies the internal queuing mechanism of the <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> instance it owns. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a407eaed77dd3da0b6d483bbba12f7156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407eaed77dd3da0b6d483bbba12f7156">&#9670;&nbsp;</a></span>poll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> cppkafka::RoundRobinPollStrategy::poll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99" title="Polls all assigned partitions for new messages in round-robin fashion.">PollInterface::poll</a> </dd></dl>

<p>Implements <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99">cppkafka::PollInterface</a>.</p>

</div>
</div>
<a id="a574b61ec5d1991293dc0b8a2e4d510d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574b61ec5d1991293dc0b8a2e4d510d8">&#9670;&nbsp;</a></span>poll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> cppkafka::RoundRobinPollStrategy::poll </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99" title="Polls all assigned partitions for new messages in round-robin fashion.">PollInterface::poll</a> </dd></dl>

<p>Implements <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a2371e81448c36180ce3a6782d9db044a">cppkafka::PollInterface</a>.</p>

</div>
</div>
<a id="a49a4024a8bd20b80318e287b4ad8391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a4024a8bd20b80318e287b4ad8391b">&#9670;&nbsp;</a></span>poll_batch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>, Allocator &gt; cppkafka::RoundRobinPollStrategy::poll_batch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">PollInterface::poll_batch</a> </dd></dl>

</div>
</div>
<a id="ab0c0fb2c3f920111d7636501bb2dca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c0fb2c3f920111d7636501bb2dca55">&#9670;&nbsp;</a></span>poll_batch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &gt; cppkafka::RoundRobinPollStrategy::poll_batch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_batch_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls all assigned partitions for a batch of new messages in round-robin fashion. </p>
<p>Each call to <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch()</a> will first attempt to consume from the global event queue and if the maximum batch number has not yet been filled, will attempt to fill it by reading the remaining messages from each partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_batch_size</td><td>The maximum amount of messages expected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of messages</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a407eaed77dd3da0b6d483bbba12f7156">poll()</a> or <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a49a4024a8bd20b80318e287b4ad8391b">poll_batch()</a> periodically as a keep alive mechanism, otherwise the broker will think this consumer is down and will trigger a rebalance (if using dynamic subscription) </dd></dl>

<p>Implements <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437">cppkafka::PollInterface</a>.</p>

</div>
</div>
<a id="acbc2ccc525a9dcf311bb239ee664866d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc2ccc525a9dcf311bb239ee664866d">&#9670;&nbsp;</a></span>poll_batch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>, Allocator &gt; cppkafka::RoundRobinPollStrategy::poll_batch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">PollInterface::poll_batch</a> </dd></dl>

</div>
</div>
<a id="a18d4621a17f47db3f04b774ab29de9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d4621a17f47db3f04b774ab29de9e5">&#9670;&nbsp;</a></span>poll_batch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&gt; cppkafka::RoundRobinPollStrategy::poll_batch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls all assigned partitions for a batch of new messages in round-robin fashion. </p>
<p>Same as the other overload of <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">PollInterface::poll_batch</a> but the provided timeout will be used instead of the one configured on this <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_batch_size</td><td>The maximum amount of messages expected</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout for this operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of messages </dd></dl>

<p>Implements <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#ae93266bf27e832dccd7ca904b82fa5d5">cppkafka::PollInterface</a>.</p>

</div>
</div>
<a id="a7e70e386018b776a2625a244b79e23c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e70e386018b776a2625a244b79e23c0">&#9670;&nbsp;</a></span>reset_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppkafka::RoundRobinPollStrategy::reset_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a89d1c115d5ba76f89dedc5b0bcab5f06" title="Reset the internal state of the queues.">PollStrategyBase::reset_state</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a89d1c115d5ba76f89dedc5b0bcab5f06">cppkafka::PollStrategyBase</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cppkafka/utils/<a class="el" href="../../d5/d94/roundrobin__poll__strategy_8h_source.html">roundrobin_poll_strategy.h</a></li>
<li>src/utils/roundrobin_poll_strategy.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 9 2019 11:20:30 for cppkafka by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
