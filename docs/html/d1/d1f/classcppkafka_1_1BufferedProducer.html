<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppkafka: cppkafka::BufferedProducer&lt; BufferType, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppkafka
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cppkafka</b></li><li class="navelem"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">BufferedProducer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../d3/d3a/classcppkafka_1_1BufferedProducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppkafka::BufferedProducer&lt; BufferType, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allows producing messages and waiting for them to be acknowledged by kafka brokers.  
 <a href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/d24/buffered__producer_8h_source.html">buffered_producer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc2/structcppkafka_1_1BufferedProducer_1_1TestParameters.html">TestParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7fe2e996da82cbf56fe2e06a737ce16e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16e">FlushMethod</a> { <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16ead8e87c0927539672f54462c837be0b7f">FlushMethod::Sync</a>, 
<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16ea24aa4117da86c41684ad25742832dfa6">FlushMethod::Async</a>
 }</td></tr>
<tr class="separator:a7fe2e996da82cbf56fe2e06a737ce16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22793d6f156dc8520ffb02d04ad0b125"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125">QueueFullNotification</a> { <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125a6adf97f83acf6453d4a6a4b1070f3754">QueueFullNotification::None</a>, 
<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125a78b2e167ac14fe6eedcb4ccf962aeade">QueueFullNotification::OncePerMessage</a>, 
<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125ab888a92712ce562ae99097c28d4a56cf">QueueFullNotification::EachOccurence</a>
 }</td></tr>
<tr class="separator:a22793d6f156dc8520ffb02d04ad0b125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5805a89b3d1806606035c9cdf8d6a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a> = <a class="el" href="../../d6/d3b/classcppkafka_1_1ConcreteMessageBuilder.html">ConcreteMessageBuilder</a>&lt; BufferType &gt;</td></tr>
<tr class="separator:a7d5805a89b3d1806606035c9cdf8d6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8c80fb368c40714ac799ea2fa39436"><td class="memItemLeft" align="right" valign="top"><a id="a2e8c80fb368c40714ac799ea2fa39436"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QueueType</b> = std::deque&lt; <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a>, Allocator &gt;</td></tr>
<tr class="separator:a2e8c80fb368c40714ac799ea2fa39436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af231031bc7c7cac598176ad1d9cedd8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af231031bc7c7cac598176ad1d9cedd8d">ProduceSuccessCallback</a> = std::function&lt; void(const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &amp;)&gt;</td></tr>
<tr class="separator:af231031bc7c7cac598176ad1d9cedd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b04af8fc5ba92987f0610d6bc26d47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0b04af8fc5ba92987f0610d6bc26d47">ProduceFailureCallback</a> = std::function&lt; bool(const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &amp;)&gt;</td></tr>
<tr class="separator:aa0b04af8fc5ba92987f0610d6bc26d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58091fe2c231f601e2b9d2d1fe392cf8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a58091fe2c231f601e2b9d2d1fe392cf8">ProduceTerminationCallback</a> = std::function&lt; void(const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &amp;)&gt;</td></tr>
<tr class="separator:a58091fe2c231f601e2b9d2d1fe392cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119ef8005eadc5104dadc5a8b02b4f73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a119ef8005eadc5104dadc5a8b02b4f73">FlushFailureCallback</a> = std::function&lt; bool(const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;, <a class="el" href="../../d6/d72/classcppkafka_1_1Error.html">Error</a> error)&gt;</td></tr>
<tr class="separator:a119ef8005eadc5104dadc5a8b02b4f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e2cbd27f585e2825613dd6080b7c44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a18e2cbd27f585e2825613dd6080b7c44">FlushTerminationCallback</a> = std::function&lt; void(const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;, <a class="el" href="../../d6/d72/classcppkafka_1_1Error.html">Error</a> error)&gt;</td></tr>
<tr class="separator:a18e2cbd27f585e2825613dd6080b7c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd7c8704a2247021a961ca184a16d12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a3cd7c8704a2247021a961ca184a16d12">QueueFullCallback</a> = std::function&lt; void(const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;)&gt;</td></tr>
<tr class="separator:a3cd7c8704a2247021a961ca184a16d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95f4c19f6b3a0db47800dfcb29ce07ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a95f4c19f6b3a0db47800dfcb29ce07ee">BufferedProducer</a> (<a class="el" href="../../da/d2d/classcppkafka_1_1Configuration.html">Configuration</a> config, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a95f4c19f6b3a0db47800dfcb29ce07ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffered producer using the provided configuration.  <a href="#a95f4c19f6b3a0db47800dfcb29ce07ee">More...</a><br /></td></tr>
<tr class="separator:a95f4c19f6b3a0db47800dfcb29ce07ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3079b0e9a16c9db5170097558b48e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#abb3079b0e9a16c9db5170097558b48e9">add_message</a> (const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:abb3079b0e9a16c9db5170097558b48e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a message to the producer's buffer.  <a href="#abb3079b0e9a16c9db5170097558b48e9">More...</a><br /></td></tr>
<tr class="separator:abb3079b0e9a16c9db5170097558b48e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57fa14da99db9e4a03308d896437e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af57fa14da99db9e4a03308d896437e98">add_message</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a> builder)</td></tr>
<tr class="memdesc:af57fa14da99db9e4a03308d896437e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a message to the producer's buffer.  <a href="#af57fa14da99db9e4a03308d896437e98">More...</a><br /></td></tr>
<tr class="separator:af57fa14da99db9e4a03308d896437e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77c15ff7726141016aa0a7f0d674942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af77c15ff7726141016aa0a7f0d674942">produce</a> (const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:af77c15ff7726141016aa0a7f0d674942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a message asynchronously without buffering it.  <a href="#af77c15ff7726141016aa0a7f0d674942">More...</a><br /></td></tr>
<tr class="separator:af77c15ff7726141016aa0a7f0d674942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6939ed4d72042e8a8ba69f0060ef2ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a6939ed4d72042e8a8ba69f0060ef2ae6">sync_produce</a> (const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a6939ed4d72042e8a8ba69f0060ef2ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a message synchronously without buffering it.  <a href="#a6939ed4d72042e8a8ba69f0060ef2ae6">More...</a><br /></td></tr>
<tr class="separator:a6939ed4d72042e8a8ba69f0060ef2ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9472941896abf4e2eff8d9d96edf72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#afa9472941896abf4e2eff8d9d96edf72">produce</a> (const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:afa9472941896abf4e2eff8d9d96edf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a message asynchronously without buffering it.  <a href="#afa9472941896abf4e2eff8d9d96edf72">More...</a><br /></td></tr>
<tr class="separator:afa9472941896abf4e2eff8d9d96edf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3d078d6f4df8cac42b15d94aa55727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aea3d078d6f4df8cac42b15d94aa55727">async_flush</a> ()</td></tr>
<tr class="memdesc:aea3d078d6f4df8cac42b15d94aa55727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all buffered messages and returns immediately.  <a href="#aea3d078d6f4df8cac42b15d94aa55727">More...</a><br /></td></tr>
<tr class="separator:aea3d078d6f4df8cac42b15d94aa55727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cb58731ea0dbb2c461ee2b44295691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691">flush</a> (bool preserve_order=false)</td></tr>
<tr class="memdesc:aa0cb58731ea0dbb2c461ee2b44295691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the buffered messages.  <a href="#aa0cb58731ea0dbb2c461ee2b44295691">More...</a><br /></td></tr>
<tr class="separator:aa0cb58731ea0dbb2c461ee2b44295691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5ffea53856b311001cfbf7452a5f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aaa5ffea53856b311001cfbf7452a5f03">flush</a> (std::chrono::milliseconds timeout, bool preserve_order=false)</td></tr>
<tr class="memdesc:aaa5ffea53856b311001cfbf7452a5f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the buffered messages and waits up to 'timeout'.  <a href="#aaa5ffea53856b311001cfbf7452a5f03">More...</a><br /></td></tr>
<tr class="separator:aaa5ffea53856b311001cfbf7452a5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d6de281e67807da44dd16448b4a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a182d6de281e67807da44dd16448b4a0b">wait_for_acks</a> ()</td></tr>
<tr class="separator:a182d6de281e67807da44dd16448b4a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29179e7c267ca8c10aefa64f32175b30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a29179e7c267ca8c10aefa64f32175b30">wait_for_acks</a> (std::chrono::milliseconds timeout)</td></tr>
<tr class="separator:a29179e7c267ca8c10aefa64f32175b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f29f5c091138e5db81290284c2623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aaa3f29f5c091138e5db81290284c2623">clear</a> ()</td></tr>
<tr class="separator:aaa3f29f5c091138e5db81290284c2623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aafbcf1a09d41c9ddc50697adb1c72"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a74aafbcf1a09d41c9ddc50697adb1c72">get_buffer_size</a> () const</td></tr>
<tr class="memdesc:a74aafbcf1a09d41c9ddc50697adb1c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of messages in the buffer.  <a href="#a74aafbcf1a09d41c9ddc50697adb1c72">More...</a><br /></td></tr>
<tr class="separator:a74aafbcf1a09d41c9ddc50697adb1c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8a8bb9622f26dcab82286bdfc70521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a8b8a8bb9622f26dcab82286bdfc70521">set_max_buffer_size</a> (ssize_t max_buffer_size)</td></tr>
<tr class="memdesc:a8b8a8bb9622f26dcab82286bdfc70521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum amount of messages to be enqueued in the buffer.  <a href="#a8b8a8bb9622f26dcab82286bdfc70521">More...</a><br /></td></tr>
<tr class="separator:a8b8a8bb9622f26dcab82286bdfc70521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce1be2390df5589610b0f4068ade3af"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7ce1be2390df5589610b0f4068ade3af">get_max_buffer_size</a> () const</td></tr>
<tr class="memdesc:a7ce1be2390df5589610b0f4068ade3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowed buffer size.  <a href="#a7ce1be2390df5589610b0f4068ade3af">More...</a><br /></td></tr>
<tr class="separator:a7ce1be2390df5589610b0f4068ade3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f63e43932c54af63289c066a0517d07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a2f63e43932c54af63289c066a0517d07">set_flush_method</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16e">FlushMethod</a> method)</td></tr>
<tr class="memdesc:a2f63e43932c54af63289c066a0517d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the method used to flush the internal buffer when 'max_buffer_size' is reached. Default is 'Sync'.  <a href="#a2f63e43932c54af63289c066a0517d07">More...</a><br /></td></tr>
<tr class="separator:a2f63e43932c54af63289c066a0517d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b96fc81526391312d1562364421671f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16e">FlushMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a6b96fc81526391312d1562364421671f">get_flush_method</a> () const</td></tr>
<tr class="memdesc:a6b96fc81526391312d1562364421671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the method used to flush the internal buffer.  <a href="#a6b96fc81526391312d1562364421671f">More...</a><br /></td></tr>
<tr class="separator:a6b96fc81526391312d1562364421671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d147233bef34991f9d7d6e3b9d5d7a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a30d147233bef34991f9d7d6e3b9d5d7a">get_pending_acks</a> () const</td></tr>
<tr class="memdesc:a30d147233bef34991f9d7d6e3b9d5d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of messages not yet acked by the broker.  <a href="#a30d147233bef34991f9d7d6e3b9d5d7a">More...</a><br /></td></tr>
<tr class="separator:a30d147233bef34991f9d7d6e3b9d5d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c40ffce8e636fc857d324efb01c1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a007c40ffce8e636fc857d324efb01c1d">get_total_messages_produced</a> () const</td></tr>
<tr class="memdesc:a007c40ffce8e636fc857d324efb01c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of messages successfully produced since the beginning.  <a href="#a007c40ffce8e636fc857d324efb01c1d">More...</a><br /></td></tr>
<tr class="separator:a007c40ffce8e636fc857d324efb01c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02186144f29dcac41da8faf28d73ce20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a02186144f29dcac41da8faf28d73ce20">get_total_messages_dropped</a> () const</td></tr>
<tr class="memdesc:a02186144f29dcac41da8faf28d73ce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of messages dropped since the beginning.  <a href="#a02186144f29dcac41da8faf28d73ce20">More...</a><br /></td></tr>
<tr class="separator:a02186144f29dcac41da8faf28d73ce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e215731b088135d8a5357869017a5d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a44e215731b088135d8a5357869017a5d">get_flushes_in_progress</a> () const</td></tr>
<tr class="memdesc:a44e215731b088135d8a5357869017a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total outstanding flush operations in progress.  <a href="#a44e215731b088135d8a5357869017a5d">More...</a><br /></td></tr>
<tr class="separator:a44e215731b088135d8a5357869017a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79a51d3db1b988b7d89e1299bdc800f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af79a51d3db1b988b7d89e1299bdc800f">set_max_number_retries</a> (size_t max_number_retries)</td></tr>
<tr class="memdesc:af79a51d3db1b988b7d89e1299bdc800f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of retries per message until giving up.  <a href="#af79a51d3db1b988b7d89e1299bdc800f">More...</a><br /></td></tr>
<tr class="separator:af79a51d3db1b988b7d89e1299bdc800f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95c7e0814cd31b8ca248d2e25b4f457"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af95c7e0814cd31b8ca248d2e25b4f457">get_max_number_retries</a> () const</td></tr>
<tr class="memdesc:af95c7e0814cd31b8ca248d2e25b4f457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the max number of retries.  <a href="#af95c7e0814cd31b8ca248d2e25b4f457">More...</a><br /></td></tr>
<tr class="separator:af95c7e0814cd31b8ca248d2e25b4f457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eb3c8fc56d31a008a71af46df67c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html">Producer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a62eb3c8fc56d31a008a71af46df67c38">get_producer</a> ()</td></tr>
<tr class="separator:a62eb3c8fc56d31a008a71af46df67c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed58e6c3f2fb66af52e3675e1f0a5202"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html">Producer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aed58e6c3f2fb66af52e3675e1f0a5202">get_producer</a> () const</td></tr>
<tr class="separator:aed58e6c3f2fb66af52e3675e1f0a5202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cb26fdb6693dff78cab76fa6b7939f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a44cb26fdb6693dff78cab76fa6b7939f">make_builder</a> (std::string topic)</td></tr>
<tr class="separator:a44cb26fdb6693dff78cab76fa6b7939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595abb9841a403e5a777a7f6913bd83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a595abb9841a403e5a777a7f6913bd83f">set_queue_full_notification</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125">QueueFullNotification</a> notification)</td></tr>
<tr class="separator:a595abb9841a403e5a777a7f6913bd83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef91160bd714cc5d83f5bb0ce75c590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125">QueueFullNotification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a2ef91160bd714cc5d83f5bb0ce75c590">get_queue_full_notification</a> () const</td></tr>
<tr class="separator:a2ef91160bd714cc5d83f5bb0ce75c590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab055e2cd6c10327a7d9f2c84b7b0a745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#ab055e2cd6c10327a7d9f2c84b7b0a745">set_produce_failure_callback</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0b04af8fc5ba92987f0610d6bc26d47">ProduceFailureCallback</a> callback)</td></tr>
<tr class="memdesc:ab055e2cd6c10327a7d9f2c84b7b0a745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message produce failure callback.  <a href="#ab055e2cd6c10327a7d9f2c84b7b0a745">More...</a><br /></td></tr>
<tr class="separator:ab055e2cd6c10327a7d9f2c84b7b0a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef4504cc29f9d56ddee3537596aa1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a9ef4504cc29f9d56ddee3537596aa1ea">set_produce_termination_callback</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a58091fe2c231f601e2b9d2d1fe392cf8">ProduceTerminationCallback</a> callback)</td></tr>
<tr class="memdesc:a9ef4504cc29f9d56ddee3537596aa1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message produce termination callback.  <a href="#a9ef4504cc29f9d56ddee3537596aa1ea">More...</a><br /></td></tr>
<tr class="separator:a9ef4504cc29f9d56ddee3537596aa1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b43732839a9635589a12004e61eb4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a87b43732839a9635589a12004e61eb4b">set_produce_success_callback</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af231031bc7c7cac598176ad1d9cedd8d">ProduceSuccessCallback</a> callback)</td></tr>
<tr class="memdesc:a87b43732839a9635589a12004e61eb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the successful delivery callback.  <a href="#a87b43732839a9635589a12004e61eb4b">More...</a><br /></td></tr>
<tr class="separator:a87b43732839a9635589a12004e61eb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3cf6a517c05f2b1e8e24efe621aa13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a5c3cf6a517c05f2b1e8e24efe621aa13">set_flush_failure_callback</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a119ef8005eadc5104dadc5a8b02b4f73">FlushFailureCallback</a> callback)</td></tr>
<tr class="memdesc:a5c3cf6a517c05f2b1e8e24efe621aa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local flush failure callback.  <a href="#a5c3cf6a517c05f2b1e8e24efe621aa13">More...</a><br /></td></tr>
<tr class="separator:a5c3cf6a517c05f2b1e8e24efe621aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeb82d2286f61b663e1a4da2efa243a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aaeeb82d2286f61b663e1a4da2efa243a">set_flush_termination_callback</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a18e2cbd27f585e2825613dd6080b7c44">FlushTerminationCallback</a> callback)</td></tr>
<tr class="memdesc:aaeeb82d2286f61b663e1a4da2efa243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local flush termination callback.  <a href="#aaeeb82d2286f61b663e1a4da2efa243a">More...</a><br /></td></tr>
<tr class="separator:aaeeb82d2286f61b663e1a4da2efa243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d41a4a5489a452abe0448b196fd2681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a2d41a4a5489a452abe0448b196fd2681">set_queue_full_callback</a> (<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a3cd7c8704a2247021a961ca184a16d12">QueueFullCallback</a> callback)</td></tr>
<tr class="memdesc:a2d41a4a5489a452abe0448b196fd2681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local queue full error callback.  <a href="#a2d41a4a5489a452abe0448b196fd2681">More...</a><br /></td></tr>
<tr class="separator:a2d41a4a5489a452abe0448b196fd2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aba1358f765142cb2ca929e1f9f44fdc0"><td class="memItemLeft" align="right" valign="top"><a id="aba1358f765142cb2ca929e1f9f44fdc0"></a>
<a class="el" href="../../da/dc2/structcppkafka_1_1BufferedProducer_1_1TestParameters.html">TestParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_test_parameters</b> ()</td></tr>
<tr class="separator:aba1358f765142cb2ca929e1f9f44fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BufferType, typename Allocator = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt;<br />
class cppkafka::BufferedProducer&lt; BufferType, Allocator &gt;</h3>

<p>Allows producing messages and waiting for them to be acknowledged by kafka brokers. </p>
<p>This class allows buffering messages and flushing them synchronously while also allowing to produce them just as you would using the <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html" title="Producer class.">Producer</a> class.</p>
<p>When calling either flush or wait_for_acks, the buffered producer will block until all produced messages (either buffered or sent directly) are acknowledged by the kafka brokers.</p>
<p>When producing messages, this class will handle cases where the producer's queue is full so it will poll until the production is successful.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This class is thread safe.</dd>
<dd>
Releasing buffers: For high-performance applications preferring a zero-copy approach (using PayloadPolicy::PASSTHROUGH_PAYLOAD - see warning below) it is very important to know when to safely release owned message buffers. One way is to perform individual cleanup when ProduceSuccessCallback is called. If the application produces messages in batches or has a bursty behavior another way is to check when flush operations have fully completed with <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a74aafbcf1a09d41c9ddc50697adb1c72" title="Get the number of messages in the buffer.">get_buffer_size()</a>==0 &amp;&amp; <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a44e215731b088135d8a5357869017a5d" title="Get the total outstanding flush operations in progress.">get_flushes_in_progress()</a>==0. Note that <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a30d147233bef34991f9d7d6e3b9d5d7a" title="Get the number of messages not yet acked by the broker.">get_pending_acks()</a>==0 is not always a guarantee as there is very small window when <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691" title="Flushes the buffered messages.">flush()</a> starts where <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a74aafbcf1a09d41c9ddc50697adb1c72" title="Get the number of messages in the buffer.">get_buffer_size()</a>==0 &amp;&amp; <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a30d147233bef34991f9d7d6e3b9d5d7a" title="Get the number of messages not yet acked by the broker.">get_pending_acks()</a>==0 but messages have not yet been sent to the remote broker. For applications producing messages w/o buffering, <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a30d147233bef34991f9d7d6e3b9d5d7a" title="Get the number of messages not yet acked by the broker.">get_pending_acks()</a>==0 is sufficient.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Delivery Report Callback: This class makes internal use of this function and will overwrite anything the user has supplied as part of the configuration options. Instead user should call <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a87b43732839a9635589a12004e61eb4b" title="Sets the successful delivery callback.">set_produce_success_callback()</a> and <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#ab055e2cd6c10327a7d9f2c84b7b0a745" title="Sets the message produce failure callback.">set_produce_failure_callback()</a> respectively.</dd>
<dd>
Payload Policy: For payload-owning BufferTypes such as std::string or std::vector&lt;char&gt; the default policy is set to <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html#a423b7974cc3d0986670d85d56e3efe26aa3b1cad7832a55bbd13569fc9d5b51d2" title="Means RD_KAFKA_MSG_F_COPY.">Producer::PayloadPolicy::COPY_PAYLOAD</a>. For the specific non-payload owning type <a class="el" href="../../d4/db2/classcppkafka_1_1Buffer.html" title="Represents a view of a buffer.">cppkafka::Buffer</a> the policy is <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html#a423b7974cc3d0986670d85d56e3efe26aa6f593e79bfcaaa643a3418f0e8a1382" title="Rdkafka will not copy nor free the payload.">Producer::PayloadPolicy::PASSTHROUGH_PAYLOAD</a>. In this case, librdkafka shall not make any internal copies of the message and it is the application's responsability to free the messages <em>after</em> the ProduceSuccessCallback has reported a successful delivery to avoid memory corruptions. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7d5805a89b3d1806606035c9cdf8d6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5805a89b3d1806606035c9cdf8d6a7">&#9670;&nbsp;</a></span>Builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a> =  <a class="el" href="../../d6/d3b/classcppkafka_1_1ConcreteMessageBuilder.html">ConcreteMessageBuilder</a>&lt;BufferType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concrete builder </p>

</div>
</div>
<a id="a119ef8005eadc5104dadc5a8b02b4f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119ef8005eadc5104dadc5a8b02b4f73">&#9670;&nbsp;</a></span>FlushFailureCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a119ef8005eadc5104dadc5a8b02b4f73">FlushFailureCallback</a> =  std::function&lt;bool(const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a>&amp;, <a class="el" href="../../d6/d72/classcppkafka_1_1Error.html">Error</a> error)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to indicate a message failed to be flushed</p>
<p>If this callback returns true, the message will be re-enqueued and flushed again later subject to the maximum number of retries set. If this callback is not set or returns false or if the number of retries reaches zero, the FlushTerminationCallback will be called. </p>

</div>
</div>
<a id="a18e2cbd27f585e2825613dd6080b7c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e2cbd27f585e2825613dd6080b7c44">&#9670;&nbsp;</a></span>FlushTerminationCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a18e2cbd27f585e2825613dd6080b7c44">FlushTerminationCallback</a> =  std::function&lt;void(const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a>&amp;, <a class="el" href="../../d6/d72/classcppkafka_1_1Error.html">Error</a> error)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to indicate a message was dropped after multiple flush attempts or when the retry count reaches zero.</p>
<p>The application can use this callback to track delivery failure of messages similar to the ProduceTerminationCallback. If the application is only interested in message dropped events, then FlushFailureCallback should not be set. </p>

</div>
</div>
<a id="aa0b04af8fc5ba92987f0610d6bc26d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b04af8fc5ba92987f0610d6bc26d47">&#9670;&nbsp;</a></span>ProduceFailureCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0b04af8fc5ba92987f0610d6bc26d47">ProduceFailureCallback</a> =  std::function&lt;bool(const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to indicate a message failed to be produced by the broker.</p>
<p>The returned bool indicates whether the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html" title="Allows producing messages and waiting for them to be acknowledged by kafka brokers.">BufferedProducer</a> should try to produce the message again after each failure, subject to the maximum number of retries set. If this callback is not set or returns false or if the number of retries reaches zero, the ProduceTerminationCallback will be called. </p>

</div>
</div>
<a id="af231031bc7c7cac598176ad1d9cedd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af231031bc7c7cac598176ad1d9cedd8d">&#9670;&nbsp;</a></span>ProduceSuccessCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af231031bc7c7cac598176ad1d9cedd8d">ProduceSuccessCallback</a> =  std::function&lt;void(const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to indicate a message was delivered to the broker </p>

</div>
</div>
<a id="a58091fe2c231f601e2b9d2d1fe392cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58091fe2c231f601e2b9d2d1fe392cf8">&#9670;&nbsp;</a></span>ProduceTerminationCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a58091fe2c231f601e2b9d2d1fe392cf8">ProduceTerminationCallback</a> =  std::function&lt;void(const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to indicate a message failed to be produced by the broker and was dropped.</p>
<p>The application can use this callback to track delivery failure of messages similar to the FlushTerminationCallback. If the application is only interested in message dropped events, then ProduceFailureCallback should not be set. </p>

</div>
</div>
<a id="a3cd7c8704a2247021a961ca184a16d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd7c8704a2247021a961ca184a16d12">&#9670;&nbsp;</a></span>QueueFullCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a3cd7c8704a2247021a961ca184a16d12">QueueFullCallback</a> =  std::function&lt;void(const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to indicate a RD_KAFKA_RESP_ERR__QUEUE_FULL was received when producing.</p>
<p>The <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html" title="Message builder class.">MessageBuilder</a> instance represents the message which triggered the error. This callback will be called according to the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a595abb9841a403e5a777a7f6913bd83f">set_queue_full_notification()</a> setting. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7fe2e996da82cbf56fe2e06a737ce16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe2e996da82cbf56fe2e06a737ce16e">&#9670;&nbsp;</a></span>FlushMethod</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16e">cppkafka::BufferedProducer::FlushMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7fe2e996da82cbf56fe2e06a737ce16ead8e87c0927539672f54462c837be0b7f"></a>Sync&#160;</td><td class="fielddoc"><p>Empty the buffer and wait for acks from the broker. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fe2e996da82cbf56fe2e06a737ce16ea24aa4117da86c41684ad25742832dfa6"></a>Async&#160;</td><td class="fielddoc"><p>Empty the buffer and don't wait for acks. </p>
</td></tr>
</table>

</div>
</div>
<a id="a22793d6f156dc8520ffb02d04ad0b125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22793d6f156dc8520ffb02d04ad0b125">&#9670;&nbsp;</a></span>QueueFullNotification</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator  = std::allocator&lt;ConcreteMessageBuilder&lt;BufferType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125">cppkafka::BufferedProducer::QueueFullNotification</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a22793d6f156dc8520ffb02d04ad0b125a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Don't notify (default). </p>
</td></tr>
<tr><td class="fieldname"><a id="a22793d6f156dc8520ffb02d04ad0b125a78b2e167ac14fe6eedcb4ccf962aeade"></a>OncePerMessage&#160;</td><td class="fielddoc"><p>Notify once per message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22793d6f156dc8520ffb02d04ad0b125ab888a92712ce562ae99097c28d4a56cf"></a>EachOccurence&#160;</td><td class="fielddoc"><p>Notify on each occurence. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a95f4c19f6b3a0db47800dfcb29ce07ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f4c19f6b3a0db47800dfcb29ce07ee">&#9670;&nbsp;</a></span>BufferedProducer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">BufferedProducer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d2d/classcppkafka_1_1Configuration.html">Configuration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a buffered producer using the provided configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration to be used on the actual <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html" title="Producer class.">Producer</a> object </td></tr>
    <tr><td class="paramname">alloc</td><td>The optionally supplied allocator for the internal message buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abb3079b0e9a16c9db5170097558b48e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3079b0e9a16c9db5170097558b48e9">&#9670;&nbsp;</a></span>add_message() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::add_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a message to the producer's buffer. </p>
<p>The message won't be sent until flush is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td>The builder that contains the message to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af57fa14da99db9e4a03308d896437e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57fa14da99db9e4a03308d896437e98">&#9670;&nbsp;</a></span>add_message() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::add_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a>&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a message to the producer's buffer. </p>
<p>The message won't be sent until flush is called.</p>
<p>Using this overload, you can avoid copies and construct your builder using the type you are actually using in this buffered producer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td>The builder that contains the message to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea3d078d6f4df8cac42b15d94aa55727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3d078d6f4df8cac42b15d94aa55727">&#9670;&nbsp;</a></span>async_flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::async_flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all buffered messages and returns immediately. </p>
<p>Similar to flush, it will send all messages but will not wait for acks to complete. However the underlying producer will still be flushed. </p>

</div>
</div>
<a id="aaa3f29f5c091138e5db81290284c2623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3f29f5c091138e5db81290284c2623">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears any buffered messages </p>

</div>
</div>
<a id="aa0cb58731ea0dbb2c461ee2b44295691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cb58731ea0dbb2c461ee2b44295691">&#9670;&nbsp;</a></span>flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_order</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the buffered messages. </p>
<p>This will send all messages and keep waiting until all of them are acknowledged (this is done by calling wait_for_acks).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preserve_order</td><td>If set to True, each message in the queue will be flushed only when the previous message ack is received. This may result in performance degradation as messages are sent one at a time. This calls <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a6939ed4d72042e8a8ba69f0060ef2ae6" title="Produces a message synchronously without buffering it.">sync_produce()</a> on each message in the buffer. If set to False, all messages are flushed in one batch before waiting for acks, however message reordering may occur if librdkafka setting 'messages.sent.max.retries &gt; 0'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Although it is possible to call flush from multiple threads concurrently, better performance is achieved when called from the same thread or when serialized with respect to other threads. </dd></dl>

</div>
</div>
<a id="aaa5ffea53856b311001cfbf7452a5f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5ffea53856b311001cfbf7452a5f03">&#9670;&nbsp;</a></span>flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the buffered messages and waits up to 'timeout'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum time to wait until all acks are received</td></tr>
    <tr><td class="paramname">preserve_order</td><td>True to preserve message ordering, False otherwise. See flush above for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completes and all acks have been received. </dd></dl>

</div>
</div>
<a id="a74aafbcf1a09d41c9ddc50697adb1c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74aafbcf1a09d41c9ddc50697adb1c72">&#9670;&nbsp;</a></span>get_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of messages in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of messages </dd></dl>

</div>
</div>
<a id="a6b96fc81526391312d1562364421671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b96fc81526391312d1562364421671f">&#9670;&nbsp;</a></span>get_flush_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16e">FlushMethod</a> <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_flush_method </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the method used to flush the internal buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The method </dd></dl>

</div>
</div>
<a id="a44e215731b088135d8a5357869017a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e215731b088135d8a5357869017a5d">&#9670;&nbsp;</a></span>get_flushes_in_progress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_flushes_in_progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total outstanding flush operations in progress. </p>
<p>Since flush can be called from multiple threads concurrently, this counter indicates how many operations are curretnly in progress.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of outstanding flush operations. </dd></dl>

</div>
</div>
<a id="a7ce1be2390df5589610b0f4068ade3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce1be2390df5589610b0f4068ade3af">&#9670;&nbsp;</a></span>get_max_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_max_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum allowed buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>The max buffer size. A value of -1 indicates an unbounded buffer. </dd></dl>

</div>
</div>
<a id="af95c7e0814cd31b8ca248d2e25b4f457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95c7e0814cd31b8ca248d2e25b4f457">&#9670;&nbsp;</a></span>get_max_number_retries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_max_number_retries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the max number of retries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of retries </dd></dl>

</div>
</div>
<a id="a30d147233bef34991f9d7d6e3b9d5d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d147233bef34991f9d7d6e3b9d5d7a">&#9670;&nbsp;</a></span>get_pending_acks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_pending_acks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of messages not yet acked by the broker. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of messages </dd></dl>

</div>
</div>
<a id="a62eb3c8fc56d31a008a71af46df67c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62eb3c8fc56d31a008a71af46df67c38">&#9670;&nbsp;</a></span>get_producer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html">Producer</a> &amp; <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_producer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html" title="Producer class.">Producer</a> object </p>

</div>
</div>
<a id="aed58e6c3f2fb66af52e3675e1f0a5202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed58e6c3f2fb66af52e3675e1f0a5202">&#9670;&nbsp;</a></span>get_producer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html">Producer</a> &amp; <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_producer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="../../d4/d7a/classcppkafka_1_1Producer.html" title="Producer class.">Producer</a> object </p>

</div>
</div>
<a id="a2ef91160bd714cc5d83f5bb0ce75c590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef91160bd714cc5d83f5bb0ce75c590">&#9670;&nbsp;</a></span>get_queue_full_notification()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125">QueueFullNotification</a> <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_queue_full_notification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the queue full notification type. </p>

</div>
</div>
<a id="a02186144f29dcac41da8faf28d73ce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02186144f29dcac41da8faf28d73ce20">&#9670;&nbsp;</a></span>get_total_messages_dropped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_total_messages_dropped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of messages dropped since the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of messages </dd></dl>

</div>
</div>
<a id="a007c40ffce8e636fc857d324efb01c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007c40ffce8e636fc857d324efb01c1d">&#9670;&nbsp;</a></span>get_total_messages_produced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::get_total_messages_produced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of messages successfully produced since the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of messages </dd></dl>

</div>
</div>
<a id="a44cb26fdb6693dff78cab76fa6b7939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cb26fdb6693dff78cab76fa6b7939f">&#9670;&nbsp;</a></span>make_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">BufferedProducer</a>&lt; BufferType, Allocator &gt;::<a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7d5805a89b3d1806606035c9cdf8d6a7">Builder</a> <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::make_builder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple helper to construct a builder object </p>

</div>
</div>
<a id="af77c15ff7726141016aa0a7f0d674942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77c15ff7726141016aa0a7f0d674942">&#9670;&nbsp;</a></span>produce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::produce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a message asynchronously without buffering it. </p>
<p>The message will still be tracked so that a call to flush or wait_for_acks will actually wait for it to be acknowledged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td>The builder that contains the message to be produced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method throws <a class="el" href="../../d7/d84/classcppkafka_1_1HandleException.html">cppkafka::HandleException</a> on failure </dd></dl>

</div>
</div>
<a id="afa9472941896abf4e2eff8d9d96edf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9472941896abf4e2eff8d9d96edf72">&#9670;&nbsp;</a></span>produce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::produce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a message asynchronously without buffering it. </p>
<p>The message will still be tracked so that a call to flush or wait_for_acks will actually wait for it to be acknowledged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to be produced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method throws <a class="el" href="../../d7/d84/classcppkafka_1_1HandleException.html">cppkafka::HandleException</a> on failure </dd></dl>

</div>
</div>
<a id="a5c3cf6a517c05f2b1e8e24efe621aa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3cf6a517c05f2b1e8e24efe621aa13">&#9670;&nbsp;</a></span>set_flush_failure_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_flush_failure_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a119ef8005eadc5104dadc5a8b02b4f73">FlushFailureCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the local flush failure callback. </p>
<p>This callback will be called when local message production fails during a <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691" title="Flushes the buffered messages.">flush()</a> operation. Failure errors are typically payload too large, unknown topic or unknown partition. Note that if the callback returns false, the message will be dropped from the buffer, otherwise it will be re-enqueued for later retry subject to the message retry count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call any method on the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html" title="Allows producing messages and waiting for them to be acknowledged by kafka brokers.">BufferedProducer</a> while inside this callback </dd></dl>

</div>
</div>
<a id="a2f63e43932c54af63289c066a0517d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f63e43932c54af63289c066a0517d07">&#9670;&nbsp;</a></span>set_flush_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_flush_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a7fe2e996da82cbf56fe2e06a737ce16e">FlushMethod</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the method used to flush the internal buffer when 'max_buffer_size' is reached. Default is 'Sync'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>The method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeeb82d2286f61b663e1a4da2efa243a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeeb82d2286f61b663e1a4da2efa243a">&#9670;&nbsp;</a></span>set_flush_termination_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_flush_termination_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a18e2cbd27f585e2825613dd6080b7c44">FlushTerminationCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the local flush termination callback. </p>
<p>This callback will be called when local message production fails during a <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691" title="Flushes the buffered messages.">flush()</a> operation after all previous flush attempts have failed. The message will be dropped after this callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the application only tracks dropped messages, the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a5c3cf6a517c05f2b1e8e24efe621aa13" title="Sets the local flush failure callback.">set_flush_failure_callback()</a> should not be set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call any method on the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html" title="Allows producing messages and waiting for them to be acknowledged by kafka brokers.">BufferedProducer</a> while inside this callback </dd></dl>

</div>
</div>
<a id="a8b8a8bb9622f26dcab82286bdfc70521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8a8bb9622f26dcab82286bdfc70521">&#9670;&nbsp;</a></span>set_max_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_max_buffer_size </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>max_buffer_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum amount of messages to be enqueued in the buffer. </p>
<p>After 'max_buffer_size' is reached, <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691" title="Flushes the buffered messages.">flush()</a> will be called automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The max size of the internal buffer. Allowed values are: -1 : Unlimited buffer size. Must be flushed manually (default value) 0 : Don't buffer anything. <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#abb3079b0e9a16c9db5170097558b48e9" title="Adds a message to the producer&#39;s buffer.">add_message()</a> behaves like <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af77c15ff7726141016aa0a7f0d674942" title="Produces a message asynchronously without buffering it.">produce()</a> &gt; 0 : Max number of messages before <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691" title="Flushes the buffered messages.">flush()</a> is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#abb3079b0e9a16c9db5170097558b48e9" title="Adds a message to the producer&#39;s buffer.">add_message()</a> will block when 'max_buffer_size' is reached due to <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0cb58731ea0dbb2c461ee2b44295691" title="Flushes the buffered messages.">flush()</a> </dd></dl>

</div>
</div>
<a id="af79a51d3db1b988b7d89e1299bdc800f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79a51d3db1b988b7d89e1299bdc800f">&#9670;&nbsp;</a></span>set_max_number_retries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_max_number_retries </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_number_retries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of retries per message until giving up. </p>
<p>Default is 5 </p>

</div>
</div>
<a id="ab055e2cd6c10327a7d9f2c84b7b0a745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab055e2cd6c10327a7d9f2c84b7b0a745">&#9670;&nbsp;</a></span>set_produce_failure_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_produce_failure_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#aa0b04af8fc5ba92987f0610d6bc26d47">ProduceFailureCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the message produce failure callback. </p>
<p>This will be called when the delivery report callback is executed for a message having an error. The callback should return true if the message should be re-sent, otherwise false. Note that if the callback return false, then the message will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call any method on the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html" title="Allows producing messages and waiting for them to be acknowledged by kafka brokers.">BufferedProducer</a> while inside this callback. </dd></dl>

</div>
</div>
<a id="a87b43732839a9635589a12004e61eb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b43732839a9635589a12004e61eb4b">&#9670;&nbsp;</a></span>set_produce_success_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_produce_success_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af231031bc7c7cac598176ad1d9cedd8d">ProduceSuccessCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the successful delivery callback. </p>
<p>The user can use this function to cleanup any application-owned message buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef4504cc29f9d56ddee3537596aa1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef4504cc29f9d56ddee3537596aa1ea">&#9670;&nbsp;</a></span>set_produce_termination_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_produce_termination_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a58091fe2c231f601e2b9d2d1fe392cf8">ProduceTerminationCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the message produce termination callback. </p>
<p>This will be called when the delivery report callback is executed for a message having an error and after all retries have expired and the message is dropped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the application only tracks dropped messages, the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#ab055e2cd6c10327a7d9f2c84b7b0a745" title="Sets the message produce failure callback.">set_produce_failure_callback()</a> should not be set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call any method on the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html" title="Allows producing messages and waiting for them to be acknowledged by kafka brokers.">BufferedProducer</a> while inside this callback. </dd></dl>

</div>
</div>
<a id="a2d41a4a5489a452abe0448b196fd2681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d41a4a5489a452abe0448b196fd2681">&#9670;&nbsp;</a></span>set_queue_full_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_queue_full_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a3cd7c8704a2247021a961ca184a16d12">QueueFullCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the local queue full error callback. </p>
<p>This callback will be called when local message production fails during a <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#af77c15ff7726141016aa0a7f0d674942" title="Produces a message asynchronously without buffering it.">produce()</a> operation according to the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a595abb9841a403e5a777a7f6913bd83f">set_queue_full_notification()</a> setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call any method on the <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html" title="Allows producing messages and waiting for them to be acknowledged by kafka brokers.">BufferedProducer</a> while inside this callback </dd></dl>

</div>
</div>
<a id="a595abb9841a403e5a777a7f6913bd83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595abb9841a403e5a777a7f6913bd83f">&#9670;&nbsp;</a></span>set_queue_full_notification()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::set_queue_full_notification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125">QueueFullNotification</a>&#160;</td>
          <td class="paramname"><em>notification</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the type of notification when RD_KAFKA_RESP_ERR__QUEUE_FULL is received.</p>
<p>This will call the error callback for this producer. By default this is set to <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html#a22793d6f156dc8520ffb02d04ad0b125a6adf97f83acf6453d4a6a4b1070f3754" title="Don&#39;t notify (default).">QueueFullNotification::None</a>. </p>

</div>
</div>
<a id="a6939ed4d72042e8a8ba69f0060ef2ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6939ed4d72042e8a8ba69f0060ef2ae6">&#9670;&nbsp;</a></span>sync_produce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::sync_produce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d7c/classcppkafka_1_1MessageBuilder.html">MessageBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a message synchronously without buffering it. </p>
<p>In case of failure, the message will be replayed until 'max_number_retries' is reached or until the user ProduceFailureCallback returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td>The builder that contains the message to be produced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method throws <a class="el" href="../../d7/d84/classcppkafka_1_1HandleException.html">cppkafka::HandleException</a> on failure </dd></dl>

</div>
</div>
<a id="a182d6de281e67807da44dd16448b4a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d6de281e67807da44dd16448b4a0b">&#9670;&nbsp;</a></span>wait_for_acks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::wait_for_acks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for produced message's acknowledgements from the brokers </p>

</div>
</div>
<a id="a29179e7c267ca8c10aefa64f32175b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29179e7c267ca8c10aefa64f32175b30">&#9670;&nbsp;</a></span>wait_for_acks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferType , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/d1f/classcppkafka_1_1BufferedProducer.html">cppkafka::BufferedProducer</a>&lt; BufferType, Allocator &gt;::wait_for_acks </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for produced message's acknowledgements from the brokers up to 'timeout'.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completes and all acks have been received. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cppkafka/utils/<a class="el" href="../../d0/d24/buffered__producer_8h_source.html">buffered_producer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 9 2019 11:20:30 for cppkafka by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
