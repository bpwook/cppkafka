<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppkafka: cppkafka::PollInterface Interface Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppkafka
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cppkafka</b></li><li class="navelem"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html">PollInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d9/d95/structcppkafka_1_1PollInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppkafka::PollInterface Interface Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface defining polling methods for the <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> class.  
 <a href="../../d5/d33/structcppkafka_1_1PollInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d9/d8f/poll__interface_8h_source.html">poll_interface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cppkafka::PollInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d5/d33/structcppkafka_1_1PollInterface.png" usemap="#cppkafka::PollInterface_map" alt=""/>
  <map id="cppkafka::PollInterface_map" name="cppkafka::PollInterface_map">
<area href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html" title="Base implementation of the PollInterface." alt="cppkafka::PollStrategyBase" shape="rect" coords="0,56,205,80"/>
<area href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html" title="This adapter changes the default polling strategy of the Consumer into a fair round-robin polling mec..." alt="cppkafka::RoundRobinPollStrategy" shape="rect" coords="0,112,205,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b1390a2c3498bd6482af33c707a481f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html">Consumer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a9b1390a2c3498bd6482af33c707a481f">get_consumer</a> ()=0</td></tr>
<tr class="memdesc:a9b1390a2c3498bd6482af33c707a481f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying consumer controlled by this strategy.  <a href="#a9b1390a2c3498bd6482af33c707a481f">More...</a><br /></td></tr>
<tr class="separator:a9b1390a2c3498bd6482af33c707a481f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50be863fae2043cd94b6b15151dcf470"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a50be863fae2043cd94b6b15151dcf470">set_timeout</a> (std::chrono::milliseconds timeout)=0</td></tr>
<tr class="memdesc:a50be863fae2043cd94b6b15151dcf470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout for polling functions.  <a href="#a50be863fae2043cd94b6b15151dcf470">More...</a><br /></td></tr>
<tr class="separator:a50be863fae2043cd94b6b15151dcf470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4cee619f562de22f75ec504e874bf5"><td class="memItemLeft" align="right" valign="top">virtual std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a5a4cee619f562de22f75ec504e874bf5">get_timeout</a> ()=0</td></tr>
<tr class="memdesc:a5a4cee619f562de22f75ec504e874bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timeout for polling functions.  <a href="#a5a4cee619f562de22f75ec504e874bf5">More...</a><br /></td></tr>
<tr class="separator:a5a4cee619f562de22f75ec504e874bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4b77b274872c5248f9f5f5b37a3b99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99">poll</a> ()=0</td></tr>
<tr class="memdesc:a6f4b77b274872c5248f9f5f5b37a3b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls all assigned partitions for new messages in round-robin fashion.  <a href="#a6f4b77b274872c5248f9f5f5b37a3b99">More...</a><br /></td></tr>
<tr class="separator:a6f4b77b274872c5248f9f5f5b37a3b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2371e81448c36180ce3a6782d9db044a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a2371e81448c36180ce3a6782d9db044a">poll</a> (std::chrono::milliseconds timeout)=0</td></tr>
<tr class="memdesc:a2371e81448c36180ce3a6782d9db044a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls for new messages.  <a href="#a2371e81448c36180ce3a6782d9db044a">More...</a><br /></td></tr>
<tr class="separator:a2371e81448c36180ce3a6782d9db044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb272d0b65ca939030b0c9b27217437"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437">poll_batch</a> (size_t max_batch_size)=0</td></tr>
<tr class="memdesc:a6cb272d0b65ca939030b0c9b27217437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls all assigned partitions for a batch of new messages in round-robin fashion.  <a href="#a6cb272d0b65ca939030b0c9b27217437">More...</a><br /></td></tr>
<tr class="separator:a6cb272d0b65ca939030b0c9b27217437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93266bf27e832dccd7ca904b82fa5d5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#ae93266bf27e832dccd7ca904b82fa5d5">poll_batch</a> (size_t max_batch_size, std::chrono::milliseconds timeout)=0</td></tr>
<tr class="memdesc:ae93266bf27e832dccd7ca904b82fa5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls all assigned partitions for a batch of new messages in round-robin fashion.  <a href="#ae93266bf27e832dccd7ca904b82fa5d5">More...</a><br /></td></tr>
<tr class="separator:ae93266bf27e832dccd7ca904b82fa5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface defining polling methods for the <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a> class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b1390a2c3498bd6482af33c707a481f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1390a2c3498bd6482af33c707a481f">&#9670;&nbsp;</a></span>get_consumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html">Consumer</a>&amp; cppkafka::PollInterface::get_consumer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying consumer controlled by this strategy. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the consumer instance </dd></dl>

<p>Implemented in <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a67b36c0eddb3be4f6e5baee1a76e8017">cppkafka::PollStrategyBase</a>.</p>

</div>
</div>
<a id="a5a4cee619f562de22f75ec504e874bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4cee619f562de22f75ec504e874bf5">&#9670;&nbsp;</a></span>get_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::chrono::milliseconds cppkafka::PollInterface::get_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the timeout for polling functions. </p>
<p>This calls <a class="el" href="../../d6/de6/classcppkafka_1_1KafkaHandleBase.html#a1d443c36344b98842b025d9bed63c5de" title="Gets the configured timeout.">Consumer::get_timeout</a></p>
<dl class="section return"><dt>Returns</dt><dd>The timeout </dd></dl>

<p>Implemented in <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a8e671507a1d15c97a7d038262eb32f3f">cppkafka::PollStrategyBase</a>.</p>

</div>
</div>
<a id="a6f4b77b274872c5248f9f5f5b37a3b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4b77b274872c5248f9f5f5b37a3b99">&#9670;&nbsp;</a></span>poll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> cppkafka::PollInterface::poll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls all assigned partitions for new messages in round-robin fashion. </p>
<p>Each call to <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99" title="Polls all assigned partitions for new messages in round-robin fashion.">poll()</a> will first consume from the global event queue and if there are no pending events, will attempt to consume from all partitions until a valid message is found. The timeout used on this call will be the one configured via <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a50be863fae2043cd94b6b15151dcf470" title="Sets the timeout for polling functions.">PollInterface::set_timeout</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A message. The returned message <em>might</em> be empty. It's necessary to check that it's a valid one before using it (see example above).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99" title="Polls all assigned partitions for new messages in round-robin fashion.">poll()</a> or <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">poll_batch()</a> periodically as a keep alive mechanism, otherwise the broker will think this consumer is down and will trigger a rebalance (if using dynamic subscription) </dd></dl>

<p>Implemented in <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a407eaed77dd3da0b6d483bbba12f7156">cppkafka::RoundRobinPollStrategy</a>.</p>

</div>
</div>
<a id="a2371e81448c36180ce3a6782d9db044a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371e81448c36180ce3a6782d9db044a">&#9670;&nbsp;</a></span>poll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a> cppkafka::PollInterface::poll </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls for new messages. </p>
<p>Same as the other overload of <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99" title="Polls all assigned partitions for new messages in round-robin fashion.">PollInterface::poll</a> but the provided timeout will be used instead of the one configured on this <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout to be used on this call </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a574b61ec5d1991293dc0b8a2e4d510d8">cppkafka::RoundRobinPollStrategy</a>.</p>

</div>
</div>
<a id="a6cb272d0b65ca939030b0c9b27217437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb272d0b65ca939030b0c9b27217437">&#9670;&nbsp;</a></span>poll_batch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&gt; cppkafka::PollInterface::poll_batch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_batch_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls all assigned partitions for a batch of new messages in round-robin fashion. </p>
<p>Each call to <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">poll_batch()</a> will first attempt to consume from the global event queue and if the maximum batch number has not yet been filled, will attempt to fill it by reading the remaining messages from each partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_batch_size</td><td>The maximum amount of messages expected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of messages</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6f4b77b274872c5248f9f5f5b37a3b99" title="Polls all assigned partitions for new messages in round-robin fashion.">poll()</a> or <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">poll_batch()</a> periodically as a keep alive mechanism, otherwise the broker will think this consumer is down and will trigger a rebalance (if using dynamic subscription) </dd></dl>

<p>Implemented in <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#ab0c0fb2c3f920111d7636501bb2dca55">cppkafka::RoundRobinPollStrategy</a>.</p>

</div>
</div>
<a id="ae93266bf27e832dccd7ca904b82fa5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93266bf27e832dccd7ca904b82fa5d5">&#9670;&nbsp;</a></span>poll_batch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="../../db/d15/classcppkafka_1_1Message.html">Message</a>&gt; cppkafka::PollInterface::poll_batch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls all assigned partitions for a batch of new messages in round-robin fashion. </p>
<p>Same as the other overload of <a class="el" href="../../d5/d33/structcppkafka_1_1PollInterface.html#a6cb272d0b65ca939030b0c9b27217437" title="Polls all assigned partitions for a batch of new messages in round-robin fashion.">PollInterface::poll_batch</a> but the provided timeout will be used instead of the one configured on this <a class="el" href="../../d1/d2c/classcppkafka_1_1Consumer.html" title="High level kafka consumer class.">Consumer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_batch_size</td><td>The maximum amount of messages expected</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout for this operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of messages </dd></dl>

<p>Implemented in <a class="el" href="../../d3/dc5/classcppkafka_1_1RoundRobinPollStrategy.html#a18d4621a17f47db3f04b774ab29de9e5">cppkafka::RoundRobinPollStrategy</a>.</p>

</div>
</div>
<a id="a50be863fae2043cd94b6b15151dcf470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50be863fae2043cd94b6b15151dcf470">&#9670;&nbsp;</a></span>set_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cppkafka::PollInterface::set_timeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the timeout for polling functions. </p>
<p>This calls <a class="el" href="../../d6/de6/classcppkafka_1_1KafkaHandleBase.html#a1dbc166f31af0917d2be93d3b33fb360" title="Sets the timeout for operations that require a timeout.">Consumer::set_timeout</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout to be set </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="../../d1/da5/classcppkafka_1_1PollStrategyBase.html#a78071e0bc763d891a637877753a25b54">cppkafka::PollStrategyBase</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>include/cppkafka/utils/<a class="el" href="../../d9/d8f/poll__interface_8h_source.html">poll_interface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 9 2019 11:20:30 for cppkafka by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
